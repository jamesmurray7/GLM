Y = Y, X = X, Z = Z, beta = beta, D = D, sigma = sigma, family = family,
Delta = Delta, S = S, Fi = Fi, l0i = l0i, SS = SS, Fu = Fu, haz = l0u, gamma_rep = gamma.rep, zeta = zeta,
beta_inds = beta.inds2, b_inds = b.inds2, K = K)$par
}, b = b, Y = Y, X = X, Z = Z, Delta = Delta, S = S, Fi = Fi, l0i = l0i, SS = SS,
Fu = Fu, l0u = l0u, SIMPLIFY = F)
#' And its variance ----
Sigma <- mapply(function(b, Y, X, Z, Delta, S, Fi, l0i, SS, Fu, l0u){
solve(
joint_density_sdb(b = b, Y = Y, X = X, Z = Z, beta = beta, D = D, sigma = sigma, family = family,
Delta = Delta, S = S, Fi = Fi, l0i = l0i, SS = SS, Fu = Fu, haz = l0u, gamma_rep = gamma.rep,
zeta = zeta, beta_inds = beta.inds2, b_inds = b.inds2, K = K, eps = 1e-5))
}, b = b.hat, Y = Y, X = X, Z = Z, Delta = Delta, S = S, Fi = Fi, l0i = l0i, SS = SS,
Fu = Fu, l0u = l0u, SIMPLIFY = F)
}
SigmaSplit <- lapply(Sigma, function(x) lapply(b.inds, function(y) as.matrix(x[y,y])))
bsplit <- lapply(b.hat, function(x) lapply(b.inds, function(y) x[y])) # Needed for updates to beta.
bmat <- lapply(bsplit, bind.bs) # Needed for E[\ell(\gamma,\zeta)|\b...|\Omega].
#' D ----------------------------------------
D.update <- mapply(function(Sigma, b) Sigma + tcrossprod(b), Sigma = Sigma, b = b.hat, SIMPLIFY = F)
#' \beta ------------------------------------
# Sb <- mapply(function(X, Y, Z, b){
#   Sbeta(beta, X, Y, Z, b, sigma, family, beta.inds2, K)
# }, X = X, Y = Y, Z = Z, b = bsplit, SIMPLIFY = F)
# Hb <- mapply(function(X, Y, Z, b){
#   Hbeta(beta, X, Y, Z, b, sigma, family, beta.inds2, K, .Machine$double.eps^(1/4))
# }, X = X, Y = Y, Z = Z, b = bsplit, SIMPLIFY = F)
Sb <- Sbeta2(beta, X, Y, Z, bsplit, sigma, family, beta.inds2, K)
Hb <<- Hbeta2(beta, X, Y, Z, bsplit, sigma, family, beta.inds2, K, .Machine$double.eps^(1/4))
Sbeta_q
Sbq <- mapply(function(X, Y, Z, b, S){
Sbeta_q(beta, X, Y, Z, b, sigma, family, beta.inds2, K, w, v, S)
}, X = X, Y = Y, Z = Z, b = bsplit, S = SigmaSplit, SIMPLIFY = F)
Reduce('+', Sbq)
Sb
sourceCpp('funs.cpp')
Sbq <- mapply(function(X, Y, Z, b, S){
Sbeta_q(beta, X, Y, Z, b, sigma, family, beta.inds2, K, w, v, S)
}, X = X, Y = Y, Z = Z, b = bsplit, S = SigmaSplit, SIMPLIFY = F)
Reduce('+', Sbq)
Sbq <- mapply(function(X, Y, Z, b, S){
Sbeta_q(beta, X, Y, Z, b, sigma, family, beta.inds2, K, w, v, S)
}, X = X, Y = Y, Z = Z, b = bsplit, S = SigmaSplit, SIMPLIFY = F)
sourceCpp('funs.cpp')
Sbq <- mapply(function(X, Y, Z, b, S){
Sbeta_q(beta, X, Y, Z, b, sigma, family, beta.inds2, K, w, v, S)
}, X = X, Y = Y, Z = Z, b = bsplit, S = SigmaSplit, SIMPLIFY = F)
Reduce('+', Sbq)
sourceCpp('funs.cpp')
Sbq <- mapply(function(X, Y, Z, b, S){
Sbeta_q(beta, X, Y, Z, b, sigma, family, beta.inds2, K, w, v, S)
}, X = X, Y = Y, Z = Z, b = bsplit, S = SigmaSplit, SIMPLIFY = F)
Reduce('+', Sbq)
Sb
EMstart <- proc.time()[3]
while(diff > tol && iter < maxit){
update <- EMupdate(Omega, family, X, Y, Z, b, S, SS, Fi, Fu, l0i, l0u, Delta, l0, sv, w, v, n, m, optimiser, hessian, beta.inds, b.inds, K, q)
if(!correlated) update$D[inits.long$off.inds] <- 0
params.new <- c(vech(update$D), update$beta, update$gamma, update$zeta)
if(any(unlist(family) %in%c('gaussian', 'negative.binomial'))){
gauss.inds <- which(unlist(family) == 'gaussian')
nb.inds <- which(unlist(family) == 'negative.binomial')
params.new <- c(params.new, unlist(update$sigma)[gauss.inds], unlist(update$sigma)[nb.inds])
}
names(params.new) <- names(params)
# Check convergence
diff <- difference(params, params.new, conv)
if(verbose){
print(sapply(params.new, round, 4))
message("Iteration ", iter + 1, ' maximum ', conv, ' difference: ', round(diff, 4))
}
#' Set new estimates as current
b <- update$b
D <- update$D; beta <- update$beta; sigma <- update$sigma
gamma <- update$gamma; zeta <- update$zeta
l0 <- update$l0; l0u <- update$l0u; l0i <- update$l0i
iter <- iter + 1
Omega <- list(D=D, beta = beta, sigma = sigma, gamma = gamma, zeta = zeta)
params <- params.new
}
EMend <- proc.time()[3]
coeffs <- Omega
coeffs$beta <- setNames(c(Omega$beta), names(inits.long$beta.init))
out <- list(coeffs = coeffs,
RE = do.call(rbind, b),
iter = iter,
EMtime = EMend-EMstart,
long.formulas = long.formulas,
surv.formula = surv.formula,
totaltime = proc.time()[3] - start.time)
out$hazard <- cbind(ft = sv$ft, haz = l0, nev = sv$nev)
out$family <- family
out$ResponseInfo <- sapply(1:K, function(k){
paste0(inits.long$responses[k], ' (', family[k], ')')
})
message('\nCalculating SEs...')
beta.inds2 <- lapply(beta.inds, function(x) x - 1); b.inds2 <- lapply(b.inds, function(x) x - 1)
gamma.rep <- rep(gamma, sapply(b.inds, length))
start.time <- proc.time()[3]
#' b and Sigmai at MLEs
b.update <- mapply(function(b, Y, X, Z, Delta, S, Fi, l0i, SS, Fu, l0u){
optim(b, joint_density, joint_density_ddb,
Y = Y, X = X, Z = Z, beta = beta, D = D, sigma = sigma, family = family,
Delta = Delta, S = S, Fi = Fi, l0i = l0i, SS = SS, Fu = Fu, haz = l0u, gamma_rep = gamma.rep, zeta = zeta,
beta_inds = beta.inds2, b_inds = b.inds2, K = K,
method = 'BFGS', hessian = T)
}, b = b, Y = Y, X = X, Z = Z, Delta = Delta, S = S, Fi = Fi, l0i = l0i, SS = SS,
Fu = Fu, l0u = l0u, SIMPLIFY = F)
Sigma <- lapply(b.update, function(x) solve(x$hessian))
b <- lapply(b.update, function(x) x$par)
SigmaSplit <- lapply(Sigma, function(x) lapply(b.inds, function(y) as.matrix(x[y,y])))
bsplit <- lapply(b, function(x) lapply(b.inds, function(y) x[y])) # Needed for updates to beta.
# The Information matrix
if(SEs != 'score'){
I <- structure(vcov(coeffs, dmats, surv, sv,
Sigma, SigmaSplit, b, bsplit,
l0u, w, v, n, family, K, q, beta.inds, b.inds, SEs),
dimnames = list(names(params), names(params)))
}else{
sigmas <- lapply(1:K, function(k){
if(!family[[k]]%in%c('gaussian', 'negative.binomial')) NULL else Omega$sigma[[k]]
})
Omega2 <- list(D = vech(Omega$D), beta = c(Omega$beta), gamma = Omega$gamma, zeta = Omega$zeta, sigma = sigmas)
np <- names(params)
if(!SE.D){
Omega2$D <- NULL
np <- np[!grepl('^D\\[', np)]
}
H <- structure(.H(unlist(Omega2), dmats, surv, sv, Sigma, SigmaSplit, b, bsplit, l0u, w, v, n, family, K, q,
beta.inds, b.inds, verbose = verbose, SE.D = SE.D),
dimnames = list(np, np))
I <- -H
}
Sbeta_q
#' The fixed effects, \beta
Sb <- mapply(function(X, Y, Z, b){
Sbeta(beta, X, Y, Z, b, sigma, family, beta.inds2, K)
}, X = X, Y = Y, Z = Z, b = bsplit, SIMPLIFY = F)
Sbq <- mapply(function(X, Y, Z, b, S){
Sbeta_q(beta, X, Y, Z, b, sigma, family, beta.inds2, K, w, v, S)
}, X = X, Y = Y, Z = Z, b = bsplit, S = SigmaSplit, SIMPLIFY = F)
Ss <- vector('list', K)
#' The dispersion parameter, \sigma
if(any(unlist(family) == 'gaussian')){
gauss.inds <- which(unlist(family) == 'gaussian')
for(j in seq_along(gauss.inds)){
temp <- numeric(n)
gj <- gauss.inds[j]
tau <- mapply(function(S, Z) sqrt(diag(tcrossprod(Z[[gj]] %*% S[[gj]],
Z[[gj]]))), Z = Z, S = SigmaSplit, SIMPLIFY = F)
for(i in 1:n){
rhs <- 0
for(l in 1:length(w)){
rhs <- rhs + w[l] * crossprod(Y[[i]][[gj]] - X[[i]][[gj]] %*% beta[beta.inds[[gj]]] - Z[[i]][[gj]] %*% bsplit[[i]][[gj]] - v[l] * tau[[i]])
}
temp[i] <- -m[[i]][gj]/(2 * unlist(sigma)[gj]) + 1/(2 * unlist(sigma)[gj]^2) * rhs
}
Ss[[gj]] <- temp
}
}
#' Negative binomial case
if(any(unlist(family) == 'negative.binomial')){
nb.inds <- which(unlist(family) == 'negative.binomial')
for(j in seq_along(nb.inds)){
nj <- nb.inds[j]
Ss[[nj]] <- mapply(function(X, Y, Z, b, Sigma){
Stheta(sigma[[nj]], beta[beta.inds[[nj]]], X[[nj]], Y[[nj]], Z[[nj]], b[[nj]], Sigma[[nj]], w, v, .Machine$double.eps^(1/3))
}, X = X, Y = Y, Z = Z, b = bsplit, Sigma = Sigmasplit, SIMPLIFY = T)
}
}
#' Survival parameters (\gamma, \zeta)
Sgz <- mapply(function(b, Sigma, S, SS, Fu, Fi, l0u, Delta){
Sgammazeta(c(gamma, zeta), b, Sigma, S, SS, Fu, Fi, l0u, Delta, w, v, b.inds2, K, q, .Machine$double.eps^(1/3))
}, b = b, Sigma = SigmaSplit, S = S, SS = SS, Fu = Fu, Fi = Fi, l0u = l0u, Delta = Delta, SIMPLIFY = F)
# Collate and form information --------------------------------------------
S <- mapply(function(sD, Sb, Sgz){
c(sD, c(Sb), c(Sgz))
}, sD = sD, Sb = Sbq, Sgz = Sgz)
D <- Omega$D
beta <- c(Omega$beta)
sigma <- Omega$sigma
gamma <- c(Omega$gamma)
zeta <- c(Omega$zeta)
#' Extract data objects ----
#' Longitudinal //
Z <- dmats$Z
X <- dmats$X
Y <- dmats$Y
m <- lapply(Y, function(y) sapply(y, length))
#' Survival //
S <- sv$S
SS <- sv$SS
Fi <- sv$Fi
Fu <- sv$Fu
Delta <- surv$Delta
beta.inds2 <- lapply(beta.inds, function(x) x - 1); b.inds2 <- lapply(b.inds, function(x) x - 1)
# Scores ------------------------------------------------------------------
#' The RE covariance matrix, D
Dinv <- solve(D)
vech.indices <- which(lower.tri(D, diag = T), arr.ind = T)
dimnames(vech.indices) <- NULL
delta.D <- lapply(1:nrow(vech.indices), function(d){
out <- matrix(0, nrow(D), ncol(D))
ind <- vech.indices[d, 2:1]
out[ind[1], ind[2]] <- out[ind[2], ind[1]] <- 1 # dD/dvech(d)_i
out
})
lhs <- sapply(delta.D, function(d) {
-0.5 * sum(diag(Dinv %*% d))
})
sDi <- function(i) {
mapply(function(b, S) {
out <- 0.5 * (S + tcrossprod(b)) %*% (Dinv %*% delta.D[[i]] %*% Dinv)
lhs[i] + sum(diag(out))
},
b = b, S = Sigma,
SIMPLIFY = T)
}
sD <- sapply(1:nrow(vech.indices), sDi)
sD <- lapply(1:nrow(sD), function(x) sD[x, ]) # Cast to list
#' The fixed effects, \beta
Sb <- mapply(function(X, Y, Z, b){
Sbeta(beta, X, Y, Z, b, sigma, family, beta.inds2, K)
}, X = X, Y = Y, Z = Z, b = bsplit, SIMPLIFY = F)
Sbq <- mapply(function(X, Y, Z, b, S){
Sbeta_q(beta, X, Y, Z, b, sigma, family, beta.inds2, K, w, v, S)
}, X = X, Y = Y, Z = Z, b = bsplit, S = SigmaSplit, SIMPLIFY = F)
Ss <- vector('list', K)
#' The dispersion parameter, \sigma
if(any(unlist(family) == 'gaussian')){
gauss.inds <- which(unlist(family) == 'gaussian')
for(j in seq_along(gauss.inds)){
temp <- numeric(n)
gj <- gauss.inds[j]
tau <- mapply(function(S, Z) sqrt(diag(tcrossprod(Z[[gj]] %*% S[[gj]],
Z[[gj]]))), Z = Z, S = SigmaSplit, SIMPLIFY = F)
for(i in 1:n){
rhs <- 0
for(l in 1:length(w)){
rhs <- rhs + w[l] * crossprod(Y[[i]][[gj]] - X[[i]][[gj]] %*% beta[beta.inds[[gj]]] - Z[[i]][[gj]] %*% bsplit[[i]][[gj]] - v[l] * tau[[i]])
}
temp[i] <- -m[[i]][gj]/(2 * unlist(sigma)[gj]) + 1/(2 * unlist(sigma)[gj]^2) * rhs
}
Ss[[gj]] <- temp
}
}
#' Negative binomial case
if(any(unlist(family) == 'negative.binomial')){
nb.inds <- which(unlist(family) == 'negative.binomial')
for(j in seq_along(nb.inds)){
nj <- nb.inds[j]
Ss[[nj]] <- mapply(function(X, Y, Z, b, Sigma){
Stheta(sigma[[nj]], beta[beta.inds[[nj]]], X[[nj]], Y[[nj]], Z[[nj]], b[[nj]], Sigma[[nj]], w, v, .Machine$double.eps^(1/3))
}, X = X, Y = Y, Z = Z, b = bsplit, Sigma = Sigmasplit, SIMPLIFY = T)
}
}
#' Survival parameters (\gamma, \zeta)
Sgz <- mapply(function(b, Sigma, S, SS, Fu, Fi, l0u, Delta){
Sgammazeta(c(gamma, zeta), b, Sigma, S, SS, Fu, Fi, l0u, Delta, w, v, b.inds2, K, q, .Machine$double.eps^(1/3))
}, b = b, Sigma = SigmaSplit, S = S, SS = SS, Fu = Fu, Fi = Fi, l0u = l0u, Delta = Delta, SIMPLIFY = F)
# Collate and form information --------------------------------------------
S <- mapply(function(sD, Sb, Sgz){
c(sD, c(Sb), c(Sgz))
}, sD = sD, Sb = Sbq, Sgz = Sgz)
if(any(unlist(family) %in% c('gaussian', 'negative.binomial'))) S <- rbind(S, do.call(rbind, Ss))
SS <- rowSums(S) # sum S
#  observed empirical information matrix (Mclachlan and Krishnan, 2008).
I <- Reduce('+', lapply(1:n, function(i) tcrossprod(S[, i]))) - tcrossprod(SS)/n
sqrt(diag(solve(I)))
# setNames(sqrt(diag(solve(I))), names(params))
# Populate Observed variance for (gamma, zeta)
if(gamma.SE == 'exact.gamma'){
S <- sv$S; SS <- sv$SS
Hgz <- mapply(function(b, Sigma, S, SS, Fu, Fi, l0u, Delta){
Hgammazeta(c(gamma, zeta), b, Sigma, S, SS, Fu, Fi, l0u, Delta, w, v, b.inds2, K, q, .Machine$double.eps^(1/3))
}, b = b, Sigma = SigmaSplit, S = S, SS = SS, Fu = Fu, Fi = Fi, l0u = l0u, Delta = Delta, SIMPLIFY = F)
HH <- Reduce('+', Hgz)
start.gammazeta <- 1 + length(vech(D)) + length(beta)
print(start.gammazeta)
print(length(gamma)); print(length(zeta))
print(HH)
I[start.gammazeta:(start.gammazeta - 1 + length(gamma) + length(zeta)),
start.gammazeta:(start.gammazeta - 1 + length(gamma) + length(zeta))] <- (-HH)
}
setNames(sqrt(diag(solve(I))), names(params))
# Collate and form information --------------------------------------------
S <- mapply(function(sD, Sb, Sgz){
c(sD, c(Sb), c(Sgz))
}, sD = sD, Sb = Sb, Sgz = Sgz)
if(any(unlist(family) %in% c('gaussian', 'negative.binomial'))) S <- rbind(S, do.call(rbind, Ss))
SS <- rowSums(S) # sum S
#  observed empirical information matrix (Mclachlan and Krishnan, 2008).
I <- Reduce('+', lapply(1:n, function(i) tcrossprod(S[, i]))) - tcrossprod(SS)/n
setNames(sqrt(diag(solve(I))), names(params))
#' multis.R
#' ---
#' Multivariate + backwards elimination for PBC, starting with:
#' Continuous //
#'    serBilir, SGOT, albumin, prothrombin
#' Count //
#'    platelets,
#' Binomial //
#'    spiders, ascites, hepatomegaly.
#' ###########
rm(list=ls())
source('EM.R')
load('../PBC-case-study/PBC.RData')
lib(tidyverse)
library(tidyverse)
rm(list=ls())
pbc <- joineRML::pbc2 %>% as_tibble %>%
select(-status) %>%
rename(survtime = years, time = year, status = status2)
pbc$drug <- as.numeric(pbc$drug) - 1 # 1: active, 0: placebo
rm(list=ls())
pbc <- joineRML::pbc2 %>% as_tibble %>%
select(-status) %>%
rename(survtime = years, time = year, status = status2)
pbc$drug <- as.numeric(pbc$drug) - 1 # 1: active, 0: placebo
pbc$sex <- as.numeric(pbc$sex) - 1 # 1: female, 0: male
survdata <- pbc %>%
distinct(id, survtime, status, age, drug) %>%
mutate(`age` = as.numeric(scale(age)))
pbc <- left_join(
pbc %>% select(-age),
survdata %>% select(id, age),
'id'
)
# Response clear-up
pbc$ascites <- as.numeric(pbc$ascites) - 1 # 1: Yes
pbc$spiders <- as.numeric(pbc$spiders) - 1 # 1: Yes
pbc$hepatomegaly <- as.numeric(pbc$hepatomegaly) - 1 # 1: Yes
pbc <- as.data.frame(pbc)
save(pbc, file = '../PBC-case-study/PBC.RData')
#' multis.R
#' ---
#' Multivariate + backwards elimination for PBC, starting with:
#' Continuous //
#'    serBilir, SGOT, albumin, prothrombin
#' Count //
#'    platelets,
#' Binomial //
#'    spiders, ascites, hepatomegaly.
#' ###########
rm(list=ls())
source('EM.R')
load('../PBC-case-study/PBC.RData')
data <- pbc[!is.na(pbc$serBilir) & !is.na(pbc$SGOT) & !is.na(pbc$albumin) & !is.na(pbc$platelets) & !is.na(pbc$spiders) & !is.na(pbc$ascites) & !is.na(pbc$hepatomegaly),]
data$id <- as.numeric(as.character(data$id))
load('../PBC-case-study/PBC.RData')
pbc$drug <- as.numeric(pbc$drug) - 1 # 1: active, 0: placebo
data <- pbc[!is.na(pbc$serBilir) & !is.na(pbc$SGOT) & !is.na(pbc$albumin) & !is.na(pbc$platelets) & !is.na(pbc$spiders) & !is.na(pbc$ascites) & !is.na(pbc$hepatomegaly),]
data$id <- as.numeric(as.character(data$id))
uid <- unique(data$id)
diff(uid) # check no ID differences > 1, or program wont work.
data$serBilir <- log(data$serBilir)
data$SGOT <- log(data$SGOT)
data$prothrombin <- (.1*data$prothrombin)^(-4)
surv.formula <- Surv(survtime, status) ~ drug # Global
# Count -------------------------------------------------------------------
# ((Univariate))
pois <- EM(list(platelets ~  drug * splines::ns(time, knots = c(1, 4)) + (1 + splines::ns(time, knots = c(1, 4))|id)),
surv.formula, data, list(poisson), control = list(SEs = 'appx'))
my.summary(pois)
source('EM.R')
vcov
# Count -------------------------------------------------------------------
# ((Univariate))
pois <- EM(list(platelets ~  drug * splines::ns(time, knots = c(1, 4)) + (1 + splines::ns(time, knots = c(1, 4))|id)),
surv.formula, data, list(poisson), control = list(SEs = 'appx'))
my.summary(pois)
#' multis.R
#' ---
#' Multivariate + backwards elimination for PBC, starting with:
#' Continuous //
#'    serBilir, SGOT, albumin, prothrombin
#' Count //
#'    platelets,
#' Binomial //
#'    spiders, ascites, hepatomegaly.
#' ###########
rm(list=ls())
source('EM.R')
load('../PBC-case-study/PBC.RData')
data <- pbc[!is.na(pbc$serBilir) & !is.na(pbc$SGOT) & !is.na(pbc$albumin) & !is.na(pbc$platelets) & !is.na(pbc$spiders) & !is.na(pbc$ascites) & !is.na(pbc$hepatomegaly),]
data$id <- as.numeric(as.character(data$id))
uid <- unique(data$id)
diff(uid) # check no ID differences > 1, or program wont work.
data$serBilir <- log(data$serBilir)
data$SGOT <- log(data$SGOT)
data$prothrombin <- (.1*data$prothrombin)^(-4)
surv.formula <- Surv(survtime, status) ~ drug # Global
rm(list=ls())
source('EM.R')
load('../PBC-case-study/PBC.RData')
data <- pbc[!is.na(pbc$serBilir) & !is.na(pbc$SGOT) & !is.na(pbc$albumin) & !is.na(pbc$platelets) & !is.na(pbc$spiders) & !is.na(pbc$ascites) & !is.na(pbc$hepatomegaly),]
data$id <- as.numeric(as.character(data$id))
uid <- unique(data$id)
diff(uid) # check no ID differences > 1, or program wont work.
data$serBilir <- log(data$serBilir)
data$SGOT <- log(data$SGOT)
data$prothrombin <- (.1*data$prothrombin)^(-4)
surv.formula <- Surv(survtime, status) ~ drug # Global
# Count -------------------------------------------------------------------
# ((Univariate))
pois <- EM(list(platelets ~  drug * splines::ns(time, knots = c(1, 4)) + (1 + splines::ns(time, knots = c(1, 4))|id)),
surv.formula, data, list(poisson), control = list(SEs = 'appx'))
my.summary(pois)
my.summary(pois)
my.summary(pois)
# Rustand -----------------------------------------------------------------
long.formulas <- list(
serBilir ~ drug * splines::ns(time, knots = c(1, 4)) + (1 + splines::ns(time, knots = c(1, 4))|id),
SGOT ~ drug * splines::ns(time, knots = c(1, 4)) + (1 + splines::ns(time, knots = c(1, 4))|id),
albumin ~ drug * time + (1 + time|id),
platelets ~ drug * splines::ns(time, knots = c(1, 4)) + (1 + splines::ns(time, knots = c(1, 4))|id),
spiders ~ drug * time + (1|id)
)
surv.formula
fit1 <- EM(long.formulas, surv.formulas,
data, list('gaussian', 'gaussian', 'gaussian', 'poisson', 'binomial'),
control = list(correlated = F, verbose = T))
fit2 <- EM(long.formulas, surv.formulas,
data, list('gaussian', 'gaussian', 'gaussian', 'poisson', 'binomial'),
control = list(correlated = F, verbose = T, SEs = 'exact.gamma'))
fit1 <- EM(long.formulas, surv.formula,
data, list('gaussian', 'gaussian', 'gaussian', 'poisson', 'binomial'),
control = list(correlated = F, verbose = T))
fit2 <- EM(long.formulas, surv.formula,
data, list('gaussian', 'gaussian', 'gaussian', 'poisson', 'binomial'),
control = list(correlated = F, verbose = T, SEs = 'exact.gamma'))
my.summary(fit1)
my.summary(fit2)
my.summary(fit2)
data$serBilir
data$SGOT
pbc$SGOT
pbc$SGOT %>% log
Hbeta_q
fit1
fit1$D
fit1$coeffs$D
vech(fit1$coeffs$D)
length(vech(fit1$coeffs$D))
length(fit1$coeffs$betq)
length(fit1$coeffs$bet)
source('EM.R')
fit2 <- EM(long.formulas, surv.formula,
data, list('gaussian', 'gaussian', 'gaussian', 'poisson', 'binomial'),
control = list(correlated = F, verbose = T, SEs = 'exact'))
source('EM.R')
fit2 <- EM(long.formulas, surv.formula,
data, list('gaussian', 'gaussian', 'gaussian', 'poisson', 'binomial'),
control = list(correlated = F, verbose = T, SEs = 'exact'))
fit2$vcov
fit2$vcov[120,]
fit2$vcov[120,120]
start.beta <- 1 + length(vech(fit2$coeffs$D))
start.beta
fit2$vcov[start.beta:(start.beta - 1 + length(fit2$coeffs$beta)),start.beta:(start.beta - 1 + length(fit2$coeffs$beta))]
diag(fit2$vcov[start.beta:(start.beta - 1 + length(fit2$coeffs$beta)),start.beta:(start.beta - 1 + length(fit2$coeffs$beta))])
diag(solve(fit2$vcov)[start.beta:(start.beta - 1 + length(fit2$coeffs$beta)),start.beta:(start.beta - 1 + length(fit2$coeffs$beta))])
diag(solve(fit2$vcov)[start.beta:(start.beta - 1 + length(fit2$coeffs$beta)),start.beta:(start.beta - 1 + length(fit2$coeffs$beta))])
sqrt(diag(solve(fit2$vcov)[start.beta:(start.beta - 1 + length(fit2$coeffs$beta)),start.beta:(start.beta - 1 + length(fit2$coeffs$beta))]))
sqrt(diag(solve(fit2$vcov)[start.beta:(start.beta - 1 + length(fit2$coeffs$beta)),start.beta:(start.beta - 1 + length(fit2$coeffs$beta))]))
#' multis.R
#' ---
#' Multivariate + backwards elimination for PBC, starting with:
#' Continuous //
#'    serBilir, SGOT, albumin, prothrombin
#' Count //
#'    platelets,
#' Binomial //
#'    spiders, ascites, hepatomegaly.
#' ###########
rm(list=ls())
source('EM.R')
load('../PBC-case-study/PBC.RData')
data <- pbc[!is.na(pbc$serBilir) & !is.na(pbc$SGOT) & !is.na(pbc$albumin) & !is.na(pbc$platelets) & !is.na(pbc$spiders) & !is.na(pbc$ascites) & !is.na(pbc$hepatomegaly),]
data$id <- as.numeric(as.character(data$id))
uid <- unique(data$id)
diff(uid) # check no ID differences > 1, or program wont work.
data$serBilir <- log(data$serBilir)
data$SGOT <- log(data$SGOT)
data$prothrombin <- (.1*data$prothrombin)^(-4)
surv.formula <- Surv(survtime, status) ~ drug # Global
# Rustand -----------------------------------------------------------------
long.formulas <- list(
serBilir ~ drug * splines::ns(time, knots = c(1, 4)) + (1 + splines::ns(time, knots = c(1, 4))|id),
SGOT ~ drug * splines::ns(time, knots = c(1, 4)) + (1 + splines::ns(time, knots = c(1, 4))|id),
albumin ~ drug * time + (1 + time|id),
platelets ~ drug * splines::ns(time, knots = c(1, 4)) + (1 + splines::ns(time, knots = c(1, 4))|id),
spiders ~ drug * time + (1|id)
)
fit1 <- EM(long.formulas, surv.formula,
data, list('gaussian', 'gaussian', 'gaussian', 'poisson', 'binomial'),
control = list(correlated = F, verbose = T, gh.nodes = 9))
my.summary(Fit1)
my.summary(fit1)
fit2 <- EM(long.formulas, surv.formula,
data, list('gaussian', 'gaussian', 'gaussian', 'poisson', 'binomial'),
control = list(correlated = F, verbose = T, SEs = 'exact'))
fit2b <- EM(long.formulas, surv.formula,
data, list('gaussian', 'gaussian', 'gaussian', 'poisson', 'binomial'),
control = list(correlated = T, verbose = T, SEs = 'exact'))
my.summary(fit2)
my.summary(fit2)
my.summary(fit2b)
my.summary(fit2)
my.summary(fit2b)
my.summary(fit2,T)
my.summary(fit2,T)
q('no')
